#!/bin/bash

set -e

entry="$1"
output="$2"
included=()
resolving=()

if [[ -z "$output" || -z "$entry" ]]; then
  echo "Usage: $0 <output-file.sh> <entry-file.sh>"
  exit 1
fi

touch "$output"
> "$output"
echo "#!/bin/bash" > "$output"
echo "" >> "$output"
echo "# Generated by bundle.sh from $entry" >> "$output"
echo "" >> "$output"

resolve_path() {
  local parent="$1"
  local relpath="$2"
  local dir
  dir="$(cd "$(dirname "$parent")" && pwd)"
  echo "$dir/$relpath"
}

bundle_file() {
  local file="$1"
  local abs_file
  abs_file="$(realpath "$file")"

  for r in "${resolving[@]}"; do
    if [[ "$r" == "$abs_file" ]]; then
      echo "❌ Circular dependency detected: $abs_file"
      exit 1
    fi
  done

  for included_file in "${included[@]}"; do
    if [[ "$included_file" == "$abs_file" ]]; then
      return
    fi
  done

  resolving+=("$abs_file")
  included+=("$abs_file")

  echo "# --- START: $file ---" >> "$output"

  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" =~ ^[[:space:]]*(source|\.)[[:space:]]+\"\\?\$?\(dirname\ \"\$0\"\)/([^\"]+)\" ]]; then
      relative="${BASH_REMATCH[2]}"
      resolved="$(resolve_path "$file" "$relative")"
      bundle_file "$resolved"
    elif [[ "$line" =~ ^[[:space:]]*(source|\.)[[:space:]]+\"([^\"]+)\" ]]; then
      resolved="$(resolve_path "$file" "${BASH_REMATCH[2]}")"
      bundle_file "$resolved"
    elif [[ "$line" =~ ^#! ]]; then
      continue  # skip shebang
    elif [[ "$line" =~ ^[[:space:]]*(source|\.) ]]; then
      echo "# Skipped: $line" >> "$output"
    else
      echo "$line" >> "$output"
    fi
  done < "$file"

  echo "# --- END: $file ---" >> "$output"
  echo "" >> "$output"

  resolving=("${resolving[@]/$abs_file}")  # pop current file
}

bundle_file "$entry"
chmod +x "$output"
echo "✅ Output written to $output"
