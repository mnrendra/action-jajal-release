#!/bin/bash
set -euo pipefail
IFS=$'\n\t'

entry="$1"
output="$2"
included=()
resolving=()
set_emitted=0
ifs_emitted=0

if [[ -z "$output" || -z "$entry" ]]; then
  echo "Usage: $0 <output-file.sh> <entry-file.sh>"
  exit 1
fi

touch "$output"
> "$output"
echo "#!/bin/bash" > "$output"
echo "" >> "$output"
echo "# Generated by bundle.sh from $entry" >> "$output"
echo "" >> "$output"

resolve_path() {
  local parent="$1"
  local relpath="$2"
  local dir
  dir="$(cd "$(dirname "$parent")" && pwd)"
  echo "$dir/$relpath"
}

bundle_file() {
  local file="$1"
  local abs_file
  abs_file="$(realpath "$file")"

  # Detect circular dependencies
  if [[ ${#resolving[@]} -gt 0 ]]; then
    for r in "${resolving[@]}"; do
      if [[ "$r" == "$abs_file" ]]; then
        echo "❌ Circular dependency detected: $abs_file"
        exit 1
      fi
    done
  fi

  # Skip already included files
  if [[ ${#included[@]} -gt 0 ]]; then
    for included_file in "${included[@]}"; do
      if [[ "$included_file" == "$abs_file" ]]; then
        return
      fi
    done
  fi

  resolving+=("$abs_file")
  included+=("$abs_file")

  echo "# --- START: $file ---" >> "$output"

  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" =~ ^[[:space:]]*(source|\.)[[:space:]]+\"\\?\$?\(dirname\ \"\$0\"\)/([^\"]+)\" ]]; then
      relative="${BASH_REMATCH[2]}"
      resolved="$(resolve_path "$file" "$relative")"
      bundle_file "$resolved"
    elif [[ "$line" =~ ^[[:space:]]*(source|\.)[[:space:]]+\"([^\"]+)\" ]]; then
      resolved="$(resolve_path "$file" "${BASH_REMATCH[2]}")"
      bundle_file "$resolved"
    elif [[ "$line" =~ ^#! ]]; then
      # skip shebang
      continue
    elif [[ "$line" =~ ^[[:space:]]*set[[:space:]]+-euo[[:space:]]+pipefail ]]; then
      if [[ "$set_emitted" -eq 0 ]]; then
        echo "$line" >> "$output"
        set_emitted=1
      else
        echo "# Skipped duplicated: $line" >> "$output"
      fi
    elif [[ "$line" =~ ^[[:space:]]*IFS[[:space:]]*=[[:space:]]*(\$\'\\?n\\?\\t\'|'\$\\?n\\?\\t'|\"\$\\?n\\?\\t\") ]]; then
      if [[ "$ifs_emitted" -eq 0 ]]; then
        echo "$line" >> "$output"
        ifs_emitted=1
      else
        echo "# Skipped duplicated: $line" >> "$output"
      fi
    elif [[ "$line" =~ ^[[:space:]]*(source|\.) ]]; then
      echo "# Skipped: $line" >> "$output"
    else
      echo "$line" >> "$output"
    fi
  done < "$file"

  echo "# --- END: $file ---" >> "$output"
  echo "" >> "$output"

  # Remove current file from resolving list safely
  local tmp
  tmp=()
  if [[ ${#resolving[@]} -gt 0 ]]; then
    for r in "${resolving[@]}"; do
      if [[ "$r" != "$abs_file" ]]; then
        tmp+=("$r")
      fi
    done
  fi

  if [[ ${#tmp[@]} -gt 0 ]]; then
    resolving=("${tmp[@]}")
  else
    resolving=()
  fi
}

bundle_file "$entry"
chmod +x "$output"
echo "✅ Output written to $output"
